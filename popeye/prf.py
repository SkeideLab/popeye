#!/usr/bin/python

""" Classes and functions for fitting population encoding models """

from __future__ import division, print_function, absolute_import
import time
import warnings
warnings.simplefilter("ignore")

import numpy as np
from scipy.optimize import brute, fmin_powell
from scipy.special import gamma
from scipy.stats import linregress

import popeye.utilities as utils
from popeye.base import PopulationModel, PopulationFit
from popeye.spinach import MakeFastPrediction

def double_gamma_hrf(delay,TR):
    """
    The double-gamma hemodynamic reponse function (HRF) used to convolve with
    the stimulus time-series.
    
    The user specifies only the delay of the peak and under-shoot The delay
    shifts the peak and under-shoot by a variable number of seconds.  The other
    parameters are hard-coded.  The HRF delay is modeled for each voxel
    independently.  The double-gamme HRF andhard-coded values are based on
    previous work (Glover, 1999).
    
    
    Parameters
    ----------
    delay : float
        The delay of the HRF peak and under-shoot.
    
    TR : float
        The length of the repetition time in seconds.
        
        
    Returns
    -------
    hrf : ndarray
        The hemodynamic response function to convolve with the stimulus
        time-series.
    
    
    Reference
    ----------
    Glover, G.H. (1999) Deconvolution of impulse response in event-related BOLD.
    fMRI. NeuroImage 9: 416 429.
    
    """
    
    # add delay to the peak and undershoot params (alpha 1 and 2)
    alpha_1 = 6.0/TR+delay/TR
    beta_1 = 1.0
    c = 0.2
    alpha_2 = 16.0/TR+delay/TR
    beta_2 = 1.0
    
    t = np.arange(0,33/TR,TR)
    scale = 1
    hrf = scale*( ( ( t ** (alpha_1) * beta_1 ** alpha_1 *
                      np.exp( -beta_1 * t )) /gamma( alpha_1 )) - c *
                  ( ( t ** (alpha_2 ) * beta_2 ** alpha_2 * np.exp( -beta_2 * t ))
                      /gamma( alpha_2 ) ) )
            
    return hrf

def compute_model_ts(x, y, sigma, hrf_delay, tr_length, deg_x, deg_y,
                    stim_arr, norm_func=utils.zscore):
    
    # otherwise generate a prediction
    ts_stim = MakeFastPrediction(deg_x,
                                 deg_y,
                                 stim_arr,
                                 x,
                                 y,
                                 sigma)
    
    # compute the hrf
    hrf = double_gamma_hrf(hrf_delay, tr_length)
    
    # convolve and trim
    model_ts = np.convolve(ts_stim, hrf)
    model_ts = model_ts[0:stim_arr.shape[-1]]
    
    # normalized it
    model_ts = norm_func(model_ts)
    
    return model_ts


def error_function(parameters, response_ts, deg_x, deg_y, stim_arr, tr_length):
    """
    The objective function that yields a minimizeable error between the
    predicted and actual BOLD time-series.
    
    The objective function takes candidate pRF estimates `parameters`,
    including a parameter for the screen location (x,y) and dispersion (sigma)
    of the 2D Gaussian as well as the HRF delay (tau).  The objective function
    also takes the ancillary parameters `deg_x` and `deg_y`, visual coordinate
    arrays, as well as the digitized stimulus array `stim_arr`.  The predicted
    time-series is generated by multiplying the pRF by the stimulus array and
    convolving the result with the double-gamma HRF.  The predicted time-series
    is mean centered and variance normalized.  The residual sum of squared
    errors is computed between the predicted and actual time-series and
    returned.
    
    This function makes use of the Cython optimising static compiler.
    MakeFastPrediction is written in Cython and computes the pre HRF convolved
    model time-series.
    
    Parameters
    ----------
    parameters : ndarray, tuple, list
        A quadruplet model parameters including the pRF estimate (x,y,sigma)
        and the HRF delay (tau).
        
    response_ts : ndarray
        A vector of the actual BOLD time-series extacted from a single voxel
        coordinate.
        
    deg_x : ndarray
        An array representing the horizontal extent of the visual display in
        terms of degrees of visual angle.
        
    deg_y : ndarray
        An array representing the vertical extent of the visual display in
        terms of degrees of visual angle.  stim_arr : ndarray Array_like means
        all those objects -- lists, nested lists, etc. -- that can be converted
        to an array.
    
    stim_arr: ndarray
        The binarized array representing the visual stimulus.
    
    tr_length: float
        The length of the repetition time in seconds.
        
    Returns
    -------
    error : float
        The residual sum of squared errors computed between the predicted and
        actual time-series.    
    """
    
    # unpack the tuple
    x, y, sigma, hrf_delay = parameters[:]
    
    # if the x or y are off the screen, abort with an inf
    if np.abs(x) > np.floor(np.max(deg_x))-1:
        return np.inf
    if np.abs(y) > np.floor(np.max(deg_y))-1:
        return np.inf
        
    # if the sigma is larger than the screen width, abort with an inf
    if np.abs(sigma) > np.floor(np.max(deg_y))-1:
        return np.inf
        
    # if the sigma is <= 0, abort with an inf
    if sigma <= 0:
        return np.inf
        
    # if the HRF delay parameter is greater than 4 seconds, abort with an inf
    if np.abs(hrf_delay) > 4:
        return np.inf
        
    # otherwise generate a prediction
    model_ts = compute_model_ts(x, y, sigma, hrf_delay, tr_length, deg_x, deg_y, stim_arr)
    
    # compute the RSS
    error = np.sum((model_ts-response_ts)**2)
    
    # catch NaN
    if np.isnan(np.sum(error)):
        return np.inf
        
    return error

def adaptive_brute_force_grid_search(bounds, epsilon, rounds, response_ts,
                                     deg_x, deg_y, stim_arr, tr_length):
    """ 
    An adaptive brute force grid-search to generate a ball-park pRF estimate for
    fine tuning via a gradient descent error minimization.
    
    
    The adaptive brute-force grid-search sparsely samples the parameter space
    and uses a down-sampled version of the stimulus and cooridnate matrices.
    This is intended to yield an initial, ball-park solution that is then fed
    into the more finely-tuned fmin_powell in the compute_prf_estimate method
    below. 
    
    Parameters
    ----------
    bounds : tuple
        A tuple of paired tuples for the upper and lower bounds of the model
        parameters  e.g. ((-10,10),(-10,10),((0.25,5.25),(-4,4))
    epsilon : int
        The step-size for reducing the grid-search bounds on each iteration
        through the adaptive brute-force search. 
    rounds : int
        The number of iterations through the adaptive brute-force search
    response_ts : ndarray
        A vector of the actual BOLD time-series extacted from a single voxel
        coordinate.
    deg_x : ndarray
        An array representing the horizontal extent of the visual display in
        terms of degrees of visual angle.
    deg_y : ndarray
        An array representing the vertical extent of the visual display in
        terms of degrees of visual angle.
    stim_arr : ndarray
        Array_like means all those objects -- lists, nested lists, etc. --
        that can be converted to an array.
        
    Returns
    -------
    error : float
        The residual sum of squared errors computed between the predicted and
        actual time-series. 
        
    """
    
    # set initial pass to 1
    pass_num = 1
    
    # make as many passes as the user specifies in rounds
    while pass_num <= rounds:
        
        # get a fit estimate by sparsely sampling the 4-parameter space
        phat = brute(error_function,
                     args=(response_ts, deg_x, deg_y, stim_arr, tr_length),
                     ranges=bounds,
                     Ns=5,
                     finish=None)
                 
        # recompute the grid-search bounds by halving the sampling space
        epsilon /= 2.0
        bounds = ((phat[0]-epsilon,phat[0]+epsilon),
                  (phat[1]-epsilon,phat[1]+epsilon),
                  (phat[2]-epsilon,phat[2]+epsilon),
                  (phat[3]-epsilon,phat[3]+epsilon))
                  
        # iterate the pass variable
        pass_num += 1
        
    x, y, sigma, hrf_delay = phat[0], phat[1], phat[2], phat[3]
    
    return x, y, sigma, hrf_delay

def gradient_descent_search(x, y, sigma, hrf_delay, tr_length,
                            error_function, response_ts, 
                            deg_x, deg_y, stim_arr):
                            
    [x, y, sigma, hrf_delay], err,  _, _, _, warnflag =\
        fmin_powell(error_function,(x, y, sigma, hrf_delay),
                    args=(response_ts,deg_x,deg_y,stim_arr, tr_length),
                    full_output=True,
                    disp=False)

    return x, y, sigma, hrf_delay

class GaussianModel(PopulationModel):
    
    """
    Gaussian population receptive field model.
    """
    
    def __init__(self, stimulus):
        
        # this is a weird notation
        PopulationModel.__init__(self, stimulus)
        
class GaussianFit(object):
    
    """
    Gaussian population receptive field model fitting
    """
    
    def __init__(self, data, model, bounds, tr_length, verbose):
        
        tic = time.clock()
        
        self.bounds = bounds
        self.tr_length = tr_length
        self.data = data
        
        # fit it
        self.x0, self.y0, self.s0, self.h0 = adaptive_brute_force_grid_search(self.bounds, 1, 3, self.data,
                                                                              model.stimulus.deg_x_coarse,
                                                                              model.stimulus.deg_y_coarse,
                                                                              model.stimulus.stim_arr_coarse,
                                                                              self.tr_length)
                                                                              
        self.x, self.y, self.sigma, self.hrf_delay = gradient_descent_search(self.x0, self.y0, self.s0, self.h0,
                                                                             self.tr_length,
                                                                             error_function,
                                                                             self.data, 
                                                                             model.stimulus.deg_x,
                                                                             model.stimulus.deg_y,
                                                                             model.stimulus.stim_arr)
                                                                             
        # store the modeled timeseries
        self.model_ts = compute_model_ts(self.x, self.y, self.sigma, self.hrf_delay, self.tr_length,
                                         model.stimulus.deg_x,
                                         model.stimulus.deg_y,
                                         model.stimulus.stim_arr)
        
        
        # store some fit metrics
        self.fit_stats = linregress(self.data,self.model_ts)
        self.rss = np.sum((self.data - self.model_ts)**2)
        
        toc = time.clock()
        
        # print to screen if verbose
        if verbose:
            print("%.01f%% DONE  VOXEL=(%.03d,%.03d,%.03d)  TIME=%.03d ERROR=%.03d  RVAL=%.02f" 
                  %(1.0,
                    1,
                    2,
                    3,
                    toc-tic,
                    self.rss,
                    self.fit_stats[2]))