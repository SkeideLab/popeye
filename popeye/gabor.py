#!/usr/bin/python

""" Classes and functions for fitting population encoding models """

from __future__ import division, print_function, absolute_import
import time
import warnings
warnings.simplefilter("ignore")

import numpy as np
from scipy.optimize import brute, fmin_powell
from scipy.special import gamma
from scipy.stats import linregress
from scipy.signal import decimate

from dipy.core.onetime import auto_attr

import popeye.utilities as utils
from popeye.base import PopulationModel, PopulationFit
from popeye.spinach import MakeFastGaborPrediction

def double_gamma_hrf(delay,TR):
    """
    The double-gamma hemodynamic reponse function (HRF) used to convolve with
    the stimulus time-series.
    
    The user specifies only the delay of the peak and under-shoot The delay
    shifts the peak and under-shoot by a variable number of seconds.  The other
    parameters are hard-coded.  The HRF delay is modeled for each voxel
    independently.  The double-gamme HRF andhard-coded values are based on
    previous work (Glover, 1999).
    
    
    Parameters
    ----------
    delay : float
        The delay of the HRF peak and under-shoot.
    
    TR : float
        The length of the repetition time in seconds.
        
        
    Returns
    -------
    hrf : ndarray
        The hemodynamic response function to convolve with the stimulus
        time-series.
    
    
    Reference
    ----------
    Glover, G.H. (1999) Deconvolution of impulse response in event-related BOLD.
    fMRI. NeuroImage 9: 416 429.
    
    """
    
    # add delay to the peak and undershoot params (alpha 1 and 2)
    alpha_1 = 6.0/TR+delay/TR
    beta_1 = 1.0
    c = 0.2
    alpha_2 = 16.0/TR+delay/TR
    beta_2 = 1.0
    
    t = np.arange(0,33/TR,TR)
    scale = 1
    hrf = scale*( ( ( t ** (alpha_1) * beta_1 ** alpha_1 *
                      np.exp( -beta_1 * t )) /gamma( alpha_1 )) - c *
                  ( ( t ** (alpha_2 ) * beta_2 ** alpha_2 * np.exp( -beta_2 * t ))
                      /gamma( alpha_2 ) ) )
            
    return hrf

def compute_model_ts(x, y, sigma, hrf_delay, theta, phi, cpd,
                    deg_x, deg_y, stim_arr, tr_length,
                    norm_func=utils.zscore):
    
    # otherwise generate a prediction
    ts_stim = MakeFastGaborPrediction(deg_x,
                                      deg_y,
                                      stim_arr,
                                      x,
                                      y,
                                      sigma,
                                      theta,
                                      phi,
                                      cpd)
    
    # compute the hrf
    hrf = double_gamma_hrf(hrf_delay, tr_length)
    
    # convolve and trim
    model_ts = np.convolve(ts_stim, hrf)
    model_ts = model_ts[0:stim_arr.shape[-1]]
    
    # normalized it
    model_ts = norm_func(model_ts)
    
    # decimate it
    model_ts = decimate(model_ts, 8, 5)
    
    return model_ts


def error_function(parameters, response, deg_x, deg_y, stim_arr, tr_length):
    """
    The objective function that yields a minimizeable error between the
    predicted and actual BOLD time-series.
    
    The objective function takes candidate pRF estimates `parameters`,
    including a parameter for the screen location (x,y) and dispersion (sigma)
    of the 2D gabor as well as the HRF delay (tau).  The objective function
    also takes the ancillary parameters `deg_x` and `deg_y`, visual coordinate
    arrays, as well as the digitized stimulus array `stim_arr`.  The predicted
    time-series is generated by multiplying the pRF by the stimulus array and
    convolving the result with the double-gamma HRF.  The predicted time-series
    is mean centered and variance normalized.  The residual sum of squared
    errors is computed between the predicted and actual time-series and
    returned.
    
    This function makes use of the Cython optimising static compiler.
    MakeFastPrediction is written in Cython and computes the pre HRF convolved
    model time-series.
    
    Parameters
    ----------
    parameters : ndarray, tuple, list
        A quadruplet model parameters including the pRF estimate (x,y,sigma)
        and the HRF delay (tau).
        
    response : ndarray
        A vector of the actual BOLD time-series extacted from a single voxel
        coordinate.
        
    deg_x : ndarray
        An array representing the horizontal extent of the visual display in
        terms of degrees of visual angle.
        
    deg_y : ndarray
        An array representing the vertical extent of the visual display in
        terms of degrees of visual angle.  stim_arr : ndarray Array_like means
        all those objects -- lists, nested lists, etc. -- that can be converted
        to an array.
    
    stim_arr: ndarray
        The binarized array representing the visual stimulus.
    
    tr_length: float
        The length of the repetition time in seconds.
        
    Returns
    -------
    error : float
        The residual sum of squared errors computed between the predicted and
        actual time-series.    
    """
    
    # unpack the tuple
    x, y, sigma, hrf_delay, theta, phi, cpd = parameters[:]
    
    # if the x or y are off the screen, abort with an inf
    if np.abs(x) > np.floor(np.max(deg_x))-1:
        return np.inf
    if np.abs(y) > np.floor(np.max(deg_y))-1:
        return np.inf
        
    # if the sigma is larger than the screen width, abort with an inf
    if np.abs(sigma) > np.floor(np.max(deg_y))-1:
        return np.inf
        
    # if the sigma is <= 0, abort with an inf
    if sigma <= 0:
        return np.inf
        
    # if the HRF delay parameter is greater than 4 seconds, abort with an inf
    if np.abs(hrf_delay) > 5:
        return np.inf
    
    # if the theta and phi are not between 0 and 360, abort with an inf
    if (theta or phi) < 0:
        return np.inf
    if (theta or phi) > 180:
        return np.inf
    
    # if cpd is below 0, abort with inf
    if cpd < 0:
        return np.inf
        
    # otherwise generate a prediction
    model_ts = compute_model_ts(x, y, sigma, hrf_delay, theta, phi, cpd,
                                deg_x, deg_y, stim_arr, tr_length)
    
    # compute the RSS
    error = np.sum((model_ts-response)**2)
    
    # catch NaN
    if np.isnan(np.sum(error)):
        return np.inf
    
    txt = '%.03g,%.03g,%.03g,%.03g,%.03g,%.03g,%.03g,%.03g' %(error,x,y,sigma,hrf_delay,theta,phi,cpd)
    print(txt)
    return error

def gradient_descent_search(x0, y0, s0, hrf0, theta0, phi0, cpd0,
                            error_function, response, 
                            deg_x, deg_y, stim_arr, tr_length):
                            
    [x, y, sigma, hrf_delay, theta, phi, cpd], err,  _, _, _, warnflag =\
        fmin_powell(error_function,(x0, y0, s0, hrf0, theta0, phi0, cpd0),
                    args=(response, deg_x, deg_y, stim_arr, tr_length),
                    full_output=True,
                    disp=False)
    
    return x, y, sigma, hrf_delay, theta, phi, cpd

def brute_force_search(bounds, response, error_function,
                       deg_x, deg_y, stim_arr, 
                       tr_length):

    [x0, y0, s0, hrf0, theta0, phi0, cpd0], err,  _, _ =\
        brute(error_function,
              args=(response, deg_x, deg_y, stim_arr, tr_length),
              ranges=bounds,
              Ns=5,
              finish=None,
              full_output=True,
              disp=False)

    # return the estimates
    return x0, y0, s0, hrf0, theta0, phi0, cpd0

def make_gabor(X,Y, ppd, theta, phi, trim, x0, y0, s0, cpd):
    theta_rad = theta * pi/180
    phase_rad = phase * pi/180
    
    XYt =  (X * cos(theta_rad)) + (Y * sin(theta_rad))
    XYf = XYt * cpd * pi/180
    
    grating = sin(XYf + phase_rad)
    gauss = np.exp(-((X-x0)**2+(Y-y0)**2)/(2*s0**2))
    gauss[gauss<trim] = 0
    gabor = grating*gauss
    
    return gabor

# this method is used to simply multiprocessing.Pool interactions
def parallel_fit(args):
    
    # unpackage the arguments
    response = args[0]
    model = args[1]
    bounds = args[2]
    tr_length = args[3]
    voxel_index = args[4]
    uncorrected_rval = args[5]
    verbose = args[6]
    
    # fit the data
    fit = gaborFit(response,
                      model,
                      bounds,
                      tr_length,
                      voxel_index,
                      uncorrected_rval,
                      verbose)
    return fit


class GaborModel(PopulationModel):
    
    """
    gabor population receptive field model.
    """
    
    def __init__(self, stimulus):
        
        # this is a weird notation
        PopulationModel.__init__(self, stimulus)
        
class GaborFit(object):
    
    """
    gabor population receptive field model fitting
    """
    
    def __init__(self, data, model, bounds, tr_length, voxel_index, uncorrected_rval, verbose=True):
            
        self.data = utils.zscore(data)
        self.model = model
        self.bounds = bounds
        self.tr_length = tr_length
        self.voxel_index = voxel_index
        self.uncorrected_rval = uncorrected_rval
        self.verbose = verbose
        
        tic = time.clock()
        self.fit_stats;
        toc = time.clock()
        
        # print to screen if verbose
        if self.verbose:
            print("VOXEL=(%.03d,%.03d,%.03d)  TIME=%.03d  ERROR=%.03d  RVAL=%.02f" 
                  %(self.voxel_index[0],
                    self.voxel_index[1],
                    self.voxel_index[2],
                    toc-tic,
                    self.rss,
                    self.fit_stats[2]))
                    
        
    @auto_attr
    def ballpark_estimate(self):
        return brute_force_search(self.bounds, self.data, error_function,
                                  self.model.stimulus.deg_x_coarse,
                                  self.model.stimulus.deg_y_coarse,
                                  self.model.stimulus.stim_arr_coarse,
                                  self.tr_length)
                                  
    @auto_attr
    def gabor_estimate(self):
        return gradient_descent_search(self.x0, self.y0, self.s0, self.hrf0, 
                                       self.theta0, self.phi0, self.cpd0,
                                       error_function, self.data, 
                                       self.model.stimulus.deg_x,
                                       self.model.stimulus.deg_y,
                                       self.model.stimulus.stim_arr,
                                       self.tr_length)
                                       
    @auto_attr
    def x0(self):
        return self.ballpark_estimate[0]
        
    @auto_attr
    def y0(self):
        return self.ballpark_estimate[1]
        
    @auto_attr
    def s0(self):
        return self.ballpark_estimate[2]
        
    @auto_attr
    def hrf0(self):
        return self.ballpark_estimate[3]
    
    @auto_attr
    def theta0(self):
        return self.ballpark_estimate[4]
    
    @auto_attr
    def phi0(self):
        return self.ballpark_estimate[5]

    @auto_attr
    def cpd0(self):
        return self.ballpark_estimate[6]
    
    @auto_attr
    def x(self):
        return self.gabor_estimate[0]
        
    @auto_attr
    def y(self):
        return self.gabor_estimate[1]
        
    @auto_attr
    def sigma(self):
        return self.gabor_estimate[2]
        
    @auto_attr
    def hrf_delay(self):
        return self.gabor_estimate[3]
    
    @auto_attr
    def theta(self):
        return self.gabor_estimate[4]
        
    @auto_attr
    def phi(self):
        return self.gabor_estimate[5]
        
    @auto_attr
    def cpd(self):
        return self.gabor_estimate[6]
    
        
    @auto_attr
    def model_ts(self):
        return compute_model_ts(self.x, self.y, self.sigma, self.hrf_delay, 
                                self.theta, self.phi, self.cpd,
                                self.model.stimulus.deg_x,
                                self.model.stimulus.deg_y,
                                self.model.stimulus.stim_arr,
                                self.tr_length)
    
    @auto_attr
    def fit_stats(self):
        return linregress(self.data, self.model_ts)
    
    @auto_attr
    def rss(self):
        return np.sum((self.data - self.model_ts)**2)