#!/usr/bin/python
""" Classes and functions for fitting population encoding models """
from __future__ import division, print_function, absolute_import

import warnings

import numpy as np

import scipy.optimize as opt

# from .base import PopulationModel, PopulationFit
# ValueError: Attempted relative import in non-package

class GaussianModel(PopulationModel):
    
    """
    Gaussian population receptive field model [1]_.
    """
    
    def __init__(self, stimulus, *args, **kwargs):
        
        
        """"
        
        Parameters
        ----------
        stimulus : Stimulus class instance
        
        References
        ----------
        
        .. [1] Dumoulin, S.O. & Wandell, B.A. 2008. Population receptive field 
           estimates in human visual cortex. NeuroImage 39, 647-660.
        
        
        """
        
        # this is a weird notation
        PopulationModel.__init__(self, stimulus)
        
        self.args = args
        self.kwargs = kwargs
        
        return GaussianFit(self)
        
        
class GaussianFit(PopulationFit):
    
    def double_gamma_hrf(self):
        """
        The double-gamma hemodynamic reponse function (HRF) used to convolve with
        the stimulus time-series.
        
        The user specifies only the delay of the peak and under-shoot The delay
        shifts the peak and under-shoot by a variable number of seconds.  The other
        parameters are hard-coded.  The HRF delay is modeled for each voxel
        independently.  The double-gamme HRF andhard-coded values are based on
        previous work (Glover, 1999).
        
        
        Parameters
        ----------
        delay : int
            The delay of the HRF peak and under-shoot.
            
            
        Returns
        -------
        hrf : ndarray
            The hemodynamic response function to convolve with the stimulus
            time-series.
            
            
        Reference
        ----------
        Glover, G.H. (1999) Deconvolution of impulse response in event-related BOLD.
        fMRI. NeuroImage 9: 416 429.
        
        """
        
        # add delay to the peak and undershoot params (alpha 1 and 2)
        alpha_1 = 5.0+delay
        beta_1 = 1.0
        c = 0.2
        alpha_2 = 15.0+delay
        beta_2 = 1.0
        
        t = np.arange(0,33)
        scale = 1
        hrf = scale*( ( ( t ** (alpha_1 - 1 ) * beta_1 ** alpha_1 *
                          np.exp( -beta_1 * t )) /gamma( alpha_1 )) - c *
            ( ( t ** (alpha_2 - 1 ) * beta_2 ** alpha_2 * np.exp( -beta_2 * t ))
              /gamma( alpha_2 ) ) )
              
        return hrf
        
        
    def error_function(parameters,ts_actual,self):
        """
        The objective function that yields a minimizeable error between the
        predicted and actual BOLD time-series.
        
        The objective function takes candidate pRF estimates `modelParams`,
        including a parameter for the screen location (x,y) and dispersion (sigma)
        of the 2D Gaussian as well as the HRF delay (tau).  The objective function
        also takes the ancillary parameters `deg_x` and `deg_y`, visual coordinate
        arrays, as well as the digitized stimulus array `stim_arr`.  The predicted
        time-series is generated by multiplying the pRF by the stimulus array and
        convolving the result with the double-gamma HRF.  The predicted time-series
        is mean centered and variance normalized.  The residual sum of squared
        errors is computed between the predicted and actual time-series and
        returned.
        
        This function makes use of the Cython optimising static compiler.
        MakeFastPrediction is written in Cython and computes the pre HRF convolved
        model time-series.
        
        Parameters
        ----------
        modelParams : ndarray, dtype=single/double
            A quadruplet model parameters including the pRF estimate (x,y,sigma)
            and the HRF delay (tau).
            
        ts_actual : ndarray
            A vector of the actual BOLD time-series extacted from a single voxel
            coordinate.
            
        deg_x : ndarray
            An array representing the horizontal extent of the visual display in
            terms of degrees of visual angle.
            
        deg_y : ndarray
            An array representing the vertical extent of the visual display in
            terms of degrees of visual angle.  stim_arr : ndarray Array_like means
            all those objects -- lists, nested lists, etc. -- that can be converted
            to an array.
            
        Returns
        -------
        error : float
            The residual sum of squared errors computed between the predicted and
            actual time-series.
        """
        
        # unpack the tuple
        x, y, sigma, hrf_delay = parameters[:]
        
        # if the x or y are off the screen, abort with an inf
        if np.abs(x) > np.floor(np.max(self.deg_y))-1:
            return np.inf
        if np.abs(y) > np.floor(np.max(self.deg_y))-1:
            return np.inf
            
        # if the sigma is larger than the screen width, abort with an inf
        if np.abs(sigma) > np.floor(np.max(self.deg_y))-1:
            return np.inf
            
        # if the sigma is <= 0, abort with an inf
        if sigma <= 0:
            return np.inf
            
        # if the HRF delay parameter is greater than 4 seconds, abort with an inf
        if np.abs(hrf_delay) > 4:
            return np.inf
            
        # otherwise generate a prediction
        ts_stim = MakeFastPrediction(self.deg_x,
                                     self.deg_y,
                                     self.stim_arr,
                                     x,
                                     y,
                                     sigma)
                                     
        # compute the double-gamma HRF at the specified delay
        hrf = double_gamma_hrf(hrf_delay)
        
        # convolve the stimulus time-series with the HRF
        ts_model= np.convolve(ts_stim, hrf)
        ts_model= ts_model[0:len(ts_actual)]
        
        # z-score the model time-series
        ts_model-= np.mean(ts_model)
        ts_model/= np.std(ts_model)
        
        # compute the RSS
        error = np.sum((ts_model-ts_actual)**2)
        
        # catch NaN
        if np.isnan(np.sum(error)):
            return np.inf
            
        return error   