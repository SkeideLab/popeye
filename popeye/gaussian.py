#!/usr/bin/python

""" Classes and functions for fitting population encoding models """

from __future__ import division, print_function, absolute_import
import time
import warnings
warnings.simplefilter("ignore")

import numpy as np

from scipy.optimize import brute, fmin_powell
from scipy.special import gamma
from scipy.stats import linregress
from scipy.signal import decimate
from scipy.interpolate import interp1d
import scipy.signal as ss


from dipy.core.onetime import auto_attr

import popeye.utilities as utils
from popeye.base import PopulationModel, PopulationFit
from popeye.spinach import MakeFastGaussPrediction

def compute_model_ts(x, y, sigma, hrf_delay, deg_x, deg_y,
                    stim_arr, tr_length, frames_per_tr, 
                    norm_func=utils.zscore):
    
    # otherwise generate a prediction
    ts_stim = MakeFastGaussPrediction(deg_x,
                                      deg_y,
                                      stim_arr,
                                      x,
                                      y,
                                      sigma)
    
    # convolve it
    hrf = utils.double_gamma_hrf(hrf_delay, tr_length, frames_per_tr)

    # normalize it
    model = norm_func(ss.fftconvolve(ts_stim, hrf)[0:len(ts_stim)])

    # decimate it
    if frames_per_tr > 1:
        model = ss.decimate(model, int(frames_per_tr), 1)

    return model


def error_function(parameters, response, deg_x, deg_y, 
                   stim_arr, tr_length, frames_per_tr, ppd):
    """
    The objective function that yields a minimizeable error between the
    predicted and actual BOLD time-series.
    
    The objective function takes candidate pRF estimates `parameters`,
    including a parameter for the screen location (x,y) and dispersion (sigma)
    of the 2D Gaussian as well as the HRF delay (tau).  The objective function
    also takes the ancillary parameters `deg_x` and `deg_y`, visual coordinate
    arrays, as well as the digitized stimulus array `stim_arr`.  The predicted
    time-series is generated by multiplying the pRF by the stimulus array and
    convolving the result with the double-gamma HRF.  The predicted time-series
    is mean centered and variance normalized.  The residual sum of squared
    errors is computed between the predicted and actual time-series and
    returned.
    
    This function makes use of the Cython optimising static compiler.
    MakeFastGaussPrediction is written in Cython and computes the pre HRF convolved
    model time-series.
    
    Parameters
    ----------
    parameters : ndarray, tuple, list
        A quadruplet model parameters including the pRF estimate (x,y,sigma)
        and the HRF delay (tau).
        
    response : ndarray
        A vector of the actual BOLD time-series extacted from a single voxel
        coordinate.
        
    deg_x : ndarray
        An array representing the horizontal extent of the visual display in
        terms of degrees of visual angle.
        
    deg_y : ndarray
        An array representing the vertical extent of the visual display in
        terms of degrees of visual angle.  stim_arr : ndarray Array_like means
        all those objects -- lists, nested lists, etc. -- that can be converted
        to an array.
    
    stim_arr: ndarray
        The binarized array representing the visual stimulus.
    
    tr_length: float
        The length of the repetition time in seconds.
        
    Returns
    -------
    error : float
        The residual sum of squared errors computed between the predicted and
        actual time-series.    
    """
    
    # unpack the tuple
    x, y, sigma, hrf_delay = parameters[:]
     
    visuotopic_limiter = 12 # np.floor(np.min((deg_x.max(),deg_y.max())))-2
    
    # if the x or y are off the screen, abort with an inf
    if np.abs(x) > visuotopic_limiter:
        return np.inf
    if np.abs(y) > visuotopic_limiter:
        return np.inf
    
    # you can't have a sigma smaller than a pixel
    if sigma < 1./ppd:
        return np.inf
        
    # if the sigma is larger than the screen width, abort with an inf
    if np.abs(sigma) > visuotopic_limiter:
        return np.inf
        
    # if the HRF delay parameter is greater than 4 seconds, abort with an inf
    if np.abs(hrf_delay) > 5:
        return np.inf
        
    # otherwise generate a prediction
    model_ts = compute_model_ts(x, y, sigma, hrf_delay, deg_x, deg_y,
                                stim_arr, tr_length, frames_per_tr)
    
    
    
    # if the model returns NaN, abort with inf ... this hapens if sigma is too small
    if np.any(np.isnan(model_ts)):
        return np.inf
    
    # compute the RSS
    error = np.sum((model_ts-response)**2)
    
    txt = '%.03g,%.03g,%.03g,%.03g,%.03g' %(error,x,y,sigma,hrf_delay)
    # print(txt)
    
    return error

def gradient_descent_search(x0, y0, s0, hrf0,error_function, 
                            response, deg_x, deg_y, stim_arr, 
                            tr_length, frames_per_tr, ppd):
                            
    [x, y, sigma, hrf_delay], err,  _, _, _, warnflag =\
        fmin_powell(error_function,(x0, y0, s0, hrf0),
                    args=(response, deg_x, deg_y, stim_arr, tr_length, frames_per_tr, ppd),
                    full_output=True,
                    disp=False)
    
    return x, y, sigma, hrf_delay

def brute_force_search(bounds, response, error_function,
                       deg_x, deg_y, stim_arr, 
                       tr_length, frames_per_tr, ppd):

    [x0, y0, s0, hrf0], err,  _, _ =\
        brute(error_function,
              args=(response, deg_x, deg_y, stim_arr, tr_length, frames_per_tr, ppd),
              ranges=bounds,
              Ns=5,
              finish=None,
              full_output=True,
              disp=False)

    # return the estimates
    return x0, y0, s0, hrf0
    

# this method is used to simply multiprocessing.Pool interactions
def parallel_fit(args):
    
    # unpackage the arguments
    response = args[0]
    model = args[1]
    bounds = args[2]
    tr_length = args[3]
    voxel_index = args[4]
    uncorrected_rval = args[5]
    verbose = args[6]
    
    # fit the data
    fit = GaussianFit(response,
                      model,
                      bounds,
                      tr_length,
                      voxel_index,
                      uncorrected_rval,
                      verbose)
    return fit


class GaussianModel(PopulationModel):
    
    """
    Gaussian population receptive field model.
    """
    
    def __init__(self, stimulus):
        
        # this is a weird notation
        PopulationModel.__init__(self, stimulus)
        
class GaussianFit(object):
    
    """
    Gaussian population receptive field model fitting
    """
    
    def __init__(self, data, model, bounds, tr_length, voxel_index, uncorrected_rval, verbose=True, auto_fit=True):
            
        self.data = utils.zscore(data)
        self.model = model
        self.bounds = bounds
        self.tr_length = tr_length
        self.voxel_index = voxel_index
        self.uncorrected_rval = uncorrected_rval
        self.verbose = verbose
        
        if auto_fit:
            tic = time.clock()
            # print('ballparking...')
            self.ballpark_estimate;
            # print('estimating...')
            self.gaussian_estimate;
            toc = time.clock()
            
            # print to screen if verbose
            if self.verbose:
                print("VOXEL=(%.03d,%.03d,%.03d)  TIME=%.03d  ERROR=%.03d  RVAL=%.02f" 
                      %(self.voxel_index[0],
                        self.voxel_index[1],
                        self.voxel_index[2],
                        toc-tic,
                        self.rss,
                        self.fit_stats[2]))
                    
        
    @auto_attr
    def ballpark_estimate(self):
        return brute_force_search(self.bounds, self.data, error_function,
                                  self.model.stimulus.deg_x_coarse,
                                  self.model.stimulus.deg_y_coarse,
                                  self.model.stimulus.stim_arr_coarse,
                                  self.tr_length,
                                  self.model.stimulus.frames_per_tr,
                                  self.model.stimulus.ppd * self.model.stimulus.scale_factor)
                                  
    @auto_attr
    def gaussian_estimate(self):
        return gradient_descent_search(self.x0, self.y0, self.s0, self.hrf0,
                                       error_function, self.data, 
                                       self.model.stimulus.deg_x,
                                       self.model.stimulus.deg_y,
                                       self.model.stimulus.stim_arr,
                                       self.tr_length,
                                       self.model.stimulus.frames_per_tr,
                                       self.model.stimulus.ppd)
                                       
    @auto_attr
    def x0(self):
        return self.ballpark_estimate[0]
        
    @auto_attr
    def y0(self):
        return self.ballpark_estimate[1]
        
    @auto_attr
    def s0(self):
        return self.ballpark_estimate[2]
        
    @auto_attr
    def hrf0(self):
        return self.ballpark_estimate[3]
        
    @auto_attr
    def x(self):
        return self.gaussian_estimate[0]
        
    @auto_attr
    def y(self):
        return self.gaussian_estimate[1]
        
    @auto_attr
    def sigma(self):
        return self.gaussian_estimate[2]
        
    @auto_attr
    def hrf_delay(self):
        return self.gaussian_estimate[3]
        
    @auto_attr
    def model_ts(self):
        return compute_model_ts(self.x, self.y, self.sigma, self.hrf_delay,
                                self.model.stimulus.deg_x,
                                self.model.stimulus.deg_y,
                                self.model.stimulus.stim_arr,
                                self.tr_length,
                                self.model.stimulus.frames_per_tr)
    
    @auto_attr
    def fit_stats(self):
        return linregress(self.data, self.model_ts)
    
    @auto_attr
    def rss(self):
        return np.sum((self.data - self.model_ts)**2)